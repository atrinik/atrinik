%{
/*************************************************************************
 *           Atrinik, a Multiplayer Online Role Playing Game             *
 *                                                                       *
 *   Copyright (C) 2009-2014 Alex Tokar and Atrinik Development Team     *
 *                                                                       *
 * Fork from Crossfire (Multiplayer game for X-windows).                 *
 *                                                                       *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 *                                                                       *
 * This program is distributed in the hope that it will be useful,       *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 * GNU General Public License for more details.                          *
 *                                                                       *
 * You should have received a copy of the GNU General Public License     *
 * along with this program; if not, write to the Free Software           *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             *
 *                                                                       *
 * The author can be reached at admin@atrinik.org                        *
 ************************************************************************/

/**
 * @file
 * C file generated by GNU Flex from loader.l, it handles object loading
 * related code. */

#include <global.h>
#include <loader.h>
#include <arch.h>
#include <artifact.h>
#include <toolkit_string.h>

#define YY_DECL int lex_load(int *depth, object **items, int maxdepth, \
        int map_flags, int linemode)
#define MAXDEPTH 10

static const char *yval(void);

/* that's needed to track the used buffers for recursive ccalling */
static void *cur_buffer;
static int lex_error;
static char msgbuf[HUGE_BUF * 4];
static size_t msgbuf_len;
static artifact_t *art_amask;

#define SET_ATTACK(op, type, val)  op->attack[type] = val;
#define SET_PROTECTION(op, type, val)  op->protection[type] = val;

/** Next value as integer. */
#define IVAL atoi(yval())
/** Next value as float. */
#define FVAL atof(yval())

#define YY_NO_INPUT

/**
 * This extracts the key/value from the yytext field - calls
 * object_set_value() to actually set the value.
 *
 * Function basically has to find spaces, strip out extra, etc. strchr()
 * doesn't work as good because could also be tabs.
 * @param op Object in which to insert the value.
 */
static void add_key_value(object *op)
{
    char *key = NULL, *value = NULL, *cp, *end;

    /* First, skip over leading whitespace. */
    for (cp = yytext; isspace(*cp); cp++) {
    }

    key = cp;

    /* Now look for the end of the key/field name. */
    for ( ; !isspace(*cp); cp++) {
        if (*cp == '\0') {
            /* Oops, ran out of string! Set the key with an empty value. */
            object_set_value(op, key, NULL, 1);
            return;
        }
    }

    if (*cp == '\0') {
        object_set_value(op, key, NULL, 1);
        return;
    }

    /* Chop off the key, and start at the next character. */
    *cp = '\0';
    cp++;

    if (*cp == '\0') {
        /* Was followed by one space? */
        object_set_value(op, key, NULL, 1);
        return;
    }

    /* Now looking for the value. Skip over whitespace. */
    for ( ; isspace(*cp); cp++) {
        if (*cp == '\0') {
            /* Guess not. */
            object_set_value(op, key, NULL, 1);
            return;
        }
    }

    value = cp;

    /* Got last character before NULL and strip
     * off tailing whitespace */
    for (end = value + (strlen(cp) - 1); isspace(*end); end--) {
        if (end == value) {
            /* Still no value? */
            object_set_value(op, key, NULL, 1);
            return;
        }

        *end = '\0';
    }

    object_set_value(op, key, value, 1);
}

static void set_random_protection(object *op, int val)
{
    op->protection[rndm(0, NROFATTACKS - 1)] = val;
}

static void set_random_attack(object *op, int val)
{
    op->attack[rndm(0, NROFATTACKS - 1)] = val;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wredundant-decls"
%}

LF  \x0A
CR  \x0D
NL  {CR}?{LF}

S   [ \t]+.+
WS  [ \t]*{NL}

%x MESSAGE

/* Don't have to link with -lfl with this */
%option noyywrap

/* Disable unput */
%option nounput

/* Disable tt_top_state */
%option noyy_top_state

/* need yy_push_state, yy_pop_state */
%option stack

%%

%{
int ismore = 0;
object *op = items[*depth];
lex_error = 0;
%}

^arch{S}             {
    object *tmp = op;

    if (tmp->arch != NULL) {
        tmp = get_object();
    }

    const char *archname = yval();
    tmp->arch = arch_find(archname);
    if (tmp->arch != NULL) {
        copy_object(&tmp->arch->clone, tmp, 1);
    }

    if (tmp != op) {
        artifact_t *art_amask_tmp = art_amask;
        art_amask = NULL;

        if (linemode == 1) {
            (*depth)++;

            if (*depth >= MAXDEPTH) {
                log_error("Exhausted maximum items stack size, exiting...");
                exit(1);
            }
        }

        items[*depth] = tmp;

        if (linemode == 0) {
            lex_load(depth, items, maxdepth, map_flags, linemode);

            if (tmp->arch != NULL) {
                tmp = insert_ob_in_ob(tmp, op);
            } else {
                if (!arch_in_init) {
                    LOG(DEBUG, "Discarding object without arch: %s", archname);
                }

                object_destroy(tmp);
                tmp = NULL;
            }
        }

        if (art_amask && tmp != NULL) {
            artifact_change_object(art_amask, tmp);
        }

        art_amask = art_amask_tmp;

        if (!(map_flags & MAP_STYLE) && tmp != NULL) {
            if (tmp->speed < 0.0 && tmp->arch != NULL &&
                    DBL_EQUAL(tmp->speed_left, tmp->arch->clone.speed_left)) {
                tmp->speed_left = tmp->arch->clone.speed_left +
                        rndm(0, 90) / 100.0f;
            }

            update_ob_speed(tmp);

            /* We must do this after the insert_ob_in_ob().
             * We look if we have a treasure or something else.
             * If so, we transform it now to real items.
             * This here only handles inventory items, the "base"
             * items are handled in load_objects(). */
            if (QUERY_FLAG(tmp, FLAG_AUTO_APPLY)) {
                /* auto_apply() will clear FLAG_AUTO_APPLY */
                auto_apply(tmp);
            } else if (tmp->randomitems != NULL && (map_flags & MAP_ORIGINAL) &&
                    op->type != SPAWN_POINT) {
                create_treasure(tmp->randomitems, tmp, 0,
                        get_environment_level(tmp), T_STYLE_UNSET,
                        ART_CHANCE_UNSET, 0, NULL);
            }

            if (object_initializers[tmp->type]) {
                object_initializers[tmp->type](tmp);
            }
        }
    }
}

^object{S}           {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Object lacks name.");
        exit(1);
    }

    if (op->arch != NULL) {
        FREE_AND_COPY_HASH(op->arch->name, yv);
    }

    FREE_AND_COPY_HASH(op->name, yv);
}

^msg{WS}             {
    BEGIN(MESSAGE);
    msgbuf[0] = '\0';
    msgbuf_len = 0;
}
<MESSAGE>^endmsg{WS} {
    BEGIN(INITIAL);

    /* Remove last newline. */
    msgbuf[msgbuf_len - 1] = '\0';
    FREE_AND_COPY_HASH(op->msg, msgbuf);
}
<MESSAGE>.*{NL}      {
    memcpy(msgbuf + msgbuf_len, yytext, MIN((size_t) yyleng,
            sizeof(msgbuf) - msgbuf_len - 1));
    msgbuf_len += yyleng;
}
^name{S}             {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Name without val");
    } else {
        FREE_AND_COPY_HASH(op->name, yv);
    }
}
^custom_name{S}      {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Custom name without val.");
    } else {
        FREE_AND_COPY_HASH(op->custom_name, yv);

        if (op->custom_name == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->custom_name);
        }
    }
}
^glow{S}      {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Glow without val.");
    } else {
        FREE_AND_COPY_HASH(op->glow, yv);

        if (op->glow == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->glow);
        }
    }
}
^race{S}             FREE_AND_COPY_HASH(op->race, yval());
^slaying{S}          {
    FREE_AND_COPY_HASH(op->slaying, yval());

    if (op->slaying == shstr_cons.NONE) {
        FREE_AND_CLEAR_HASH(op->slaying);
    }
}
^artifact{S}         FREE_AND_COPY_HASH(op->artifact, yval());
^amask{S}            {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Artifact mask without val");
    } else if (op->arch != NULL) {
        art_amask = artifact_find_type(yval(), op->arch->clone.type);

        if (art_amask == NULL) {
            LOG(ERROR, "Invalid amask '%s'.", yval());
        }
    }
}
^quickslot{S}        op->quickslot = IVAL;
^other_arch{S}       op->other_arch = arch_find(yval());
^animation{S}        {
    const char *yv = yval();

    if (strcmp(yv, "NONE") == 0) {
        op->animation_id = 0;
    } else {
        op->animation_id = find_animation(yv);
    }
}
^inv_animation{S}    {
    const char *yv = yval();

    if (strcmp(yv, "NONE") == 0) {
        op->inv_animation_id = 0;
    } else {
        op->inv_animation_id = find_animation(yv);
    }
}

^more{WS}            {
    /* We need to record that this is a multipart object,
     * so the calling function can glue things back together. */
    ismore = 1;
}

^end{WS}             {
    if (linemode) {
        /* Linemode is only set for artifact loading. */
        if ((*depth) > 0) {
            insert_ob_in_ob(items[*depth], items[(*depth) - 1]);
        }

        return LL_NORMAL;
    }

    if (ismore) {
        return LL_MORE;
    } else {
        return LL_NORMAL;
    }
}
^object_int1{S}      op->enemy_count = IVAL;
^object_int2{S}      op->attacked_by_count = IVAL;
^object_int3{S}      op->ownercount = IVAL;
^last_heal{S}        op->last_heal = IVAL;
^last_sp{S}          op->last_sp = IVAL;
^last_grace{S}       op->last_grace = IVAL;
^last_grace_add{S}   op->last_grace += IVAL;
^last_eat{S}         op->last_eat = IVAL;
^speed{S}            op->speed = FVAL;
^speed_left{S}       op->speed_left = FVAL;
^slow_move{S}        CHANGE_FLAG(op, FLAG_SLOW_MOVE, IVAL);
^face{S}             {
    int _face_ = find_face(yval(), 0);
    op->face = &new_faces[_face_];

    if (_face_ == 0) {
        LOG(ERROR, "Can't find face %s for object: %s", yval(),
                object_get_str(op));
    }
}
^inv_face{S}         {
    int _face_ = find_face(yval(), 0);
    op->inv_face = &new_faces[_face_];

    if (_face_ == 0) {
        LOG(ERROR, "Can't find inv_face %s for object: %s", yval(),
                object_get_str(op));
    }
}
^str{S}              op->stats.Str = IVAL;
^dex{S}              op->stats.Dex = IVAL;
^con{S}              op->stats.Con = IVAL;
^wis{S}              op->stats.Wis = IVAL;
^cha{S}              op->stats.Cha = IVAL;
^int{S}              op->stats.Int = IVAL;
^pow{S}              op->stats.Pow = IVAL;
^hp{S}               op->stats.hp = IVAL;
^maxhp{S}            op->stats.maxhp = IVAL;
^sp{S}               op->stats.sp = IVAL;
^maxsp{S}            op->stats.maxsp = IVAL;
^exp{S}              op->stats.exp = atoll(yval());
^food{S}             op->stats.food = IVAL;
^dam{S}              op->stats.dam = IVAL;
^dam_add{S}          op->stats.dam += IVAL;
^wc{S}               op->stats.wc = IVAL;
^wc_add{S}           op->stats.wc += IVAL;
^wc_range{S}         op->stats.wc_range = IVAL;
^wc_range_add{S}     op->stats.wc_range += IVAL;
^ac{S}               op->stats.ac = IVAL;
^ac_add{S}           op->stats.ac += IVAL;
^x{S}                op->x = IVAL;
^y{S}                op->y = IVAL;
^z{S}                op->z = IVAL;
^zoom{S}             op->zoom_x = op->zoom_y = IVAL;
^zoom_x{S}           op->zoom_x = IVAL;
^zoom_y{S}           op->zoom_y = IVAL;
^align{S}            op->align = IVAL;
^alpha{S}            op->alpha = IVAL;
^glow_speed{S}       op->glow_speed = IVAL;
^rotate{S}           op->rotate = IVAL;
^nrof{S}             op->nrof = atol(yval());
^level{S}            op->level = IVAL;
^direction{S}        op->direction = (IVAL % 9);
^type{S}             op->type = IVAL;
^material{S}         op->material = IVAL;
^value{S}            op->value = atoll(yval());
^weight{S}           op->weight = atol(yval());
^carrying{S}         op->carrying = atol(yval());
^path_attuned{S}     op->path_attuned = IVAL;
^path_repelled{S}    op->path_repelled = IVAL;
^path_denied{S}      op->path_denied = IVAL;
^magic{S}            op->magic = IVAL;
^state{S}            op->state = IVAL;
^layer{S}            {
    int val = IVAL;
    op->layer = MAX(0, MIN(NUM_LAYERS, val));
}
^sub_layer{S}        {
    int val = IVAL;
    op->sub_layer = MAX(0, MIN(NUM_SUB_LAYERS - 1, val));
}
^door_closed{S}      CHANGE_FLAG(op, FLAG_DOOR_CLOSED, IVAL);
^cursed_perm{S}      CHANGE_FLAG(op, FLAG_PERM_CURSED, IVAL);
^damned_perm{S}      CHANGE_FLAG(op, FLAG_PERM_DAMNED, IVAL);
^one_drop{S}         CHANGE_FLAG(op, FLAG_ONE_DROP, IVAL);
^is_trapped{S}       CHANGE_FLAG(op, FLAG_IS_TRAPPED, IVAL);
^quest_item{S}       CHANGE_FLAG(op, FLAG_QUEST_ITEM, IVAL);
^player_only{S}      CHANGE_FLAG(op, FLAG_PLAYER_ONLY, IVAL);
^is_named{S}         CHANGE_FLAG(op, FLAG_IS_NAMED, IVAL);
^is_player{S}        CHANGE_FLAG(op, FLAG_IS_PLAYER, IVAL);
^sys_object{S}       CHANGE_FLAG(op, FLAG_SYS_OBJECT, IVAL);
^generator{S}        {}
^can_stack{S}        CHANGE_FLAG(op, FLAG_CAN_STACK, IVAL);
^is_thrown{S}        CHANGE_FLAG(op, FLAG_IS_THROWN, IVAL);
^auto_apply{S}       CHANGE_FLAG(op, FLAG_AUTO_APPLY, IVAL);
^treasure{S}         {}
^is_assassin{S}      CHANGE_FLAG(op, FLAG_IS_ASSASSINATION, IVAL);
^is_spell{S}         CHANGE_FLAG(op, FLAG_IS_SPELL, IVAL);
^is_missile{S}       CHANGE_FLAG(op, FLAG_IS_MISSILE, IVAL);
^draw_direction{S}   CHANGE_FLAG(op, FLAG_DRAW_DIRECTION, IVAL);
^draw_double{S}      CHANGE_FLAG(op, FLAG_DRAW_DOUBLE, IVAL);
^draw_double_always{S} CHANGE_FLAG(op, FLAG_DRAW_DOUBLE_ALWAYS, IVAL);
^see_invisible{S}    CHANGE_FLAG(op, FLAG_SEE_INVISIBLE, IVAL);
^make_invisible{S}   CHANGE_FLAG(op, FLAG_MAKE_INVISIBLE, IVAL);
^make_ethereal{S}    CHANGE_FLAG(op, FLAG_MAKE_ETHEREAL, IVAL);
^can_roll{S}         CHANGE_FLAG(op, FLAG_CAN_ROLL, IVAL);
^connect_reset{S}    CHANGE_FLAG(op, FLAG_CONNECT_RESET, IVAL);
^is_turnable{S}      CHANGE_FLAG(op, FLAG_IS_TURNABLE, IVAL);
^is_used_up{S}       CHANGE_FLAG(op, FLAG_IS_USED_UP, IVAL);
^is_invisible{S}     CHANGE_FLAG(op, FLAG_IS_INVISIBLE, IVAL);
^alive{S}            {}
^applied{S}          CHANGE_FLAG(op, FLAG_APPLIED, IVAL);
^unpaid{S}           CHANGE_FLAG(op, FLAG_UNPAID, IVAL);
^hidden{S}           CHANGE_FLAG(op, FLAG_HIDDEN, IVAL);
^no_pick{S}          CHANGE_FLAG(op, FLAG_NO_PICK, IVAL);
^no_pass{S}          CHANGE_FLAG(op, FLAG_NO_PASS, IVAL);
^no_teleport{S}      CHANGE_FLAG(op, FLAG_NO_TELEPORT, IVAL);
^corpse{S}           CHANGE_FLAG(op, FLAG_CORPSE, IVAL);
^corpse_forced{S}    CHANGE_FLAG(op, FLAG_CORPSE_FORCED, IVAL);
^walk_on{S}          CHANGE_FLAG(op, FLAG_WALK_ON, IVAL);
^walk_off{S}         CHANGE_FLAG(op, FLAG_WALK_OFF, IVAL);
^fly_on{S}           CHANGE_FLAG(op, FLAG_FLY_ON, IVAL);
^fly_off{S}          CHANGE_FLAG(op, FLAG_FLY_OFF, IVAL);
^is_animated{S}      CHANGE_FLAG(op, FLAG_ANIMATE, IVAL);
^flying{S}           CHANGE_FLAG(op, FLAG_FLYING, IVAL);
^monster{S}          CHANGE_FLAG(op, FLAG_MONSTER, IVAL);
^no_attack{S}        CHANGE_FLAG(op, FLAG_NO_ATTACK, IVAL);
^invulnerable{S}     CHANGE_FLAG(op, FLAG_INVULNERABLE, IVAL);
^friendly{S}         CHANGE_FLAG(op, FLAG_FRIENDLY, IVAL);
^identified{S}       CHANGE_FLAG(op, FLAG_IDENTIFIED, IVAL);
^reflecting{S}       CHANGE_FLAG(op, FLAG_REFLECTING, IVAL);
^changing{S}         CHANGE_FLAG(op, FLAG_CHANGING, IVAL);
^splitting{S}        CHANGE_FLAG(op, FLAG_SPLITTING, IVAL);
^hitback{S}          CHANGE_FLAG(op, FLAG_HITBACK, IVAL);
^startequip{S}       CHANGE_FLAG(op, FLAG_STARTEQUIP, IVAL);
^blocksview{S}       CHANGE_FLAG(op, FLAG_BLOCKSVIEW, IVAL);
^undead{S}           CHANGE_FLAG(op, FLAG_UNDEAD, IVAL);
^scared{S}           CHANGE_FLAG(op, FLAG_SCARED, IVAL);
^unaggressive{S}     CHANGE_FLAG(op, FLAG_UNAGGRESSIVE, IVAL);
^reflect_missile{S}  CHANGE_FLAG(op, FLAG_REFL_MISSILE, IVAL);
^reflect_spell{S}    CHANGE_FLAG(op, FLAG_REFL_SPELL, IVAL);
^can_reflect_missile{S} CHANGE_FLAG(op, FLAG_REFL_MISSILE, IVAL);
^can_reflect_spell{S} CHANGE_FLAG(op, FLAG_REFL_SPELL, IVAL);
^no_magic{S}         CHANGE_FLAG(op, FLAG_NO_MAGIC, IVAL);
^no_fix_player{S}    CHANGE_FLAG(op, FLAG_NO_FIX_PLAYER, IVAL);
^tear_down{S}        {}
^luck{S}             {}
^run_away{S}         op->run_away = IVAL;
^pass_thru{S}        CHANGE_FLAG(op, FLAG_PASS_THRU, IVAL);
^can_pass_thru{S}    CHANGE_FLAG(op, FLAG_CAN_PASS_THRU, IVAL);
^anim_speed{S}       op->anim_speed = IVAL;
^container{S}        op->weight_limit = IVAL;
^no_drop{S}          CHANGE_FLAG(op, FLAG_NO_DROP, IVAL);
^behavior{S}         op->behavior = IVAL;
^use_fix_pos{S}      CHANGE_FLAG(op, FLAG_USE_FIX_POS, IVAL);
^is_ethereal{S}      CHANGE_FLAG(op, FLAG_IS_ETHEREAL, IVAL);
^two_handed{S}       CHANGE_FLAG(op, FLAG_TWO_HANDED, IVAL);
^can_cast_spell{S}   CHANGE_FLAG(op, FLAG_CAST_SPELL, IVAL);
^can_use_scroll{S}   {}
^can_use_range{S}    {}
^can_use_bow{S}      CHANGE_FLAG(op, FLAG_USE_BOW, IVAL);
^can_use_armour{S}   CHANGE_FLAG(op, FLAG_USE_ARMOUR, IVAL);
^can_use_weapon{S}   CHANGE_FLAG(op, FLAG_USE_WEAPON, IVAL);
^can_use_ring{S}     {}
^has_ready_range{S}  {}
^has_ready_bow{S}    CHANGE_FLAG(op, FLAG_READY_BOW, IVAL);
^xrays{S}            CHANGE_FLAG(op, FLAG_XRAYS, IVAL);
^no_save{S}          CHANGE_FLAG(op, FLAG_NO_SAVE, IVAL);
^is_floor{S}         CHANGE_FLAG(op, FLAG_IS_FLOOR, IVAL);
^is_male{S}          CHANGE_FLAG(op, FLAG_IS_MALE, IVAL);
^is_female{S}        CHANGE_FLAG(op, FLAG_IS_FEMALE, IVAL);
^is_evil{S}          CHANGE_FLAG(op, FLAG_IS_EVIL, IVAL);
^is_good{S}          CHANGE_FLAG(op, FLAG_IS_GOOD, IVAL);
^is_neutral{S}       CHANGE_FLAG(op, FLAG_IS_NEUTRAL, IVAL);
^lifesave{S}         CHANGE_FLAG(op, FLAG_LIFESAVE, IVAL);
^sleep{S}            CHANGE_FLAG(op, FLAG_SLEEP, IVAL);
^stand_still{S}      CHANGE_FLAG(op, FLAG_STAND_STILL, IVAL);
^random_move{S}      CHANGE_FLAG(op, FLAG_RANDOM_MOVE, IVAL);
^only_attack{S}      CHANGE_FLAG(op, FLAG_ONLY_ATTACK, IVAL);
^berserk{S}          CHANGE_FLAG(op, FLAG_BERSERK, IVAL);
^is_magical{S}       CHANGE_FLAG(op, FLAG_IS_MAGICAL, IVAL);
^connect_no_push{S}  CHANGE_FLAG(op, FLAG_CONNECT_NO_PUSH, IVAL);
^connect_no_release{S} CHANGE_FLAG(op, FLAG_CONNECT_NO_RELEASE, IVAL);

    /* Start of various attacktypes */
^attack_impact{S}    SET_ATTACK(op, ATNR_IMPACT, IVAL);
^attack_slash{S}     SET_ATTACK(op, ATNR_SLASH, IVAL);
^attack_cleave{S}    SET_ATTACK(op, ATNR_CLEAVE, IVAL);
^attack_pierce{S}    SET_ATTACK(op, ATNR_PIERCE, IVAL);
^attack_weaponmagic{S} SET_ATTACK(op, ATNR_WEAPON_MAGIC, IVAL);

^attack_fire{S}      SET_ATTACK(op, ATNR_FIRE, IVAL);
^attack_cold{S}      SET_ATTACK(op, ATNR_COLD, IVAL);
^attack_electricity{S} SET_ATTACK(op, ATNR_ELECTRICITY, IVAL);
^attack_poison{S}    SET_ATTACK(op, ATNR_POISON, IVAL);
^attack_acid{S}      SET_ATTACK(op, ATNR_ACID, IVAL);

^attack_magic{S}     SET_ATTACK(op, ATNR_MAGIC, IVAL);
^attack_mind{S}      SET_ATTACK(op, ATNR_MIND, IVAL);
^attack_blind{S}     SET_ATTACK(op, ATNR_BLIND, IVAL);
^attack_paralyze{S}  SET_ATTACK(op, ATNR_PARALYZE, IVAL);
^attack_force{S}     SET_ATTACK(op, ATNR_FORCE, IVAL);

^attack_godpower{S}  SET_ATTACK(op, ATNR_GODPOWER, IVAL);
^attack_chaos{S}     SET_ATTACK(op, ATNR_CHAOS, IVAL);
^attack_drain{S}     SET_ATTACK(op, ATNR_DRAIN, IVAL);
^attack_slow{S}      SET_ATTACK(op, ATNR_SLOW, IVAL);
^attack_confusion{S} SET_ATTACK(op, ATNR_CONFUSION, IVAL);

^attack_internal{S}  SET_ATTACK(op, ATNR_INTERNAL, IVAL);

    /* The following attack types are deprecated and are here
     * for backwards compatibility.
     * TODO remove these at some point. */
^attack_psionic{S}   set_random_attack(op, IVAL);
^attack_sonic{S}     set_random_attack(op, IVAL);
^attack_demonic{S}   set_random_attack(op, IVAL);
^attack_counterspell{S} set_random_attack(op, IVAL);
^attack_purity{S}    set_random_attack(op, IVAL);
^attack_life_steal{S} set_random_attack(op, IVAL);
^attack_death{S}     set_random_attack(op, IVAL);
^attack_time{S}      set_random_attack(op, IVAL);
^attack_fear{S}      set_random_attack(op, IVAL);
^attack_cancellation{S} set_random_attack(op, IVAL);
^attack_depletion{S} set_random_attack(op, IVAL);
^attack_ghosthit{S}  set_random_attack(op, IVAL);

    /* All these resists are deprecated and are here for
     * backwards compatibility.
     * TODO remove these at some point. */
^resist_impact{S}    SET_PROTECTION(op, ATNR_IMPACT, IVAL);
^resist_magic{S}     SET_PROTECTION(op, ATNR_MAGIC, IVAL);
^resist_fire{S}      SET_PROTECTION(op, ATNR_FIRE, IVAL);
^resist_electricity{S} SET_PROTECTION(op, ATNR_ELECTRICITY, IVAL);
^resist_cold{S}      SET_PROTECTION(op, ATNR_COLD, IVAL);
^resist_confusion{S} SET_PROTECTION(op, ATNR_CONFUSION, IVAL);
^resist_acid{S}      SET_PROTECTION(op, ATNR_ACID, IVAL);
^resist_drain{S}     SET_PROTECTION(op, ATNR_DRAIN, IVAL);
^resist_weaponmagic{S} SET_PROTECTION(op, ATNR_WEAPON_MAGIC, IVAL);
^resist_ghosthit{S}  set_random_protection(op, IVAL);
^resist_poison{S}    SET_PROTECTION(op, ATNR_POISON, IVAL);
^resist_slow{S}      set_random_protection(op, IVAL);
^resist_paralyze{S}  SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^resist_time{S}      set_random_protection(op, IVAL);
^resist_fear{S}      set_random_protection(op, IVAL);
^resist_cancellation{S} set_random_protection(op, IVAL);
^resist_depletion{S} set_random_protection(op, IVAL);
^resist_death{S}     set_random_protection(op, IVAL);
^resist_chaos{S}     SET_PROTECTION(op, ATNR_CHAOS, IVAL);
^resist_counterspell{S} set_random_protection(op, IVAL);
^resist_godpower{S}  SET_PROTECTION(op, ATNR_GODPOWER, IVAL);
^resist_purity{S}    set_random_protection(op, IVAL);
^resist_blind{S}     SET_PROTECTION(op, ATNR_BLIND, IVAL);
^resist_internal{S}  set_random_protection(op, IVAL);
^resist_life_steal{S} set_random_protection(op, IVAL);
^resist_slash{S}     SET_PROTECTION(op, ATNR_SLASH, IVAL);
^resist_cleave{S}    SET_PROTECTION(op, ATNR_CLEAVE, IVAL);
^resist_pierce{S}    SET_PROTECTION(op, ATNR_PIERCE, IVAL);
^resist_nether{S}    set_random_protection(op, IVAL);
^resist_sonic{S}     set_random_protection(op, IVAL);
^resist_demonic{S}   set_random_protection(op, IVAL);
^resist_psionic{S}   set_random_protection(op, IVAL);

    /* Start of various protections */
^protect_impact{S}   SET_PROTECTION(op, ATNR_IMPACT, IVAL);
^protect_slash{S}    SET_PROTECTION(op, ATNR_SLASH, IVAL);
^protect_cleave{S}   SET_PROTECTION(op, ATNR_CLEAVE, IVAL);
^protect_pierce{S}   SET_PROTECTION(op, ATNR_PIERCE, IVAL);
^protect_weaponmagic{S} SET_PROTECTION(op, ATNR_WEAPON_MAGIC, IVAL);

^protect_fire{S}     SET_PROTECTION(op, ATNR_FIRE, IVAL);
^protect_cold{S}     SET_PROTECTION(op, ATNR_COLD, IVAL);
^protect_electricity{S} SET_PROTECTION(op, ATNR_ELECTRICITY, IVAL);
^protect_poison{S}   SET_PROTECTION(op, ATNR_POISON, IVAL);
^protect_acid{S}     SET_PROTECTION(op, ATNR_ACID, IVAL);

^protect_magic{S}    SET_PROTECTION(op, ATNR_MAGIC, IVAL);
^protect_mind{S}     SET_PROTECTION(op, ATNR_MIND, IVAL);
^protect_blind{S}    SET_PROTECTION(op, ATNR_BLIND, IVAL);
^protect_paralyze{S} SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_force{S}    SET_PROTECTION(op, ATNR_FORCE, IVAL);

^protect_godpower{S} SET_PROTECTION(op, ATNR_GODPOWER, IVAL);
^protect_chaos{S}    SET_PROTECTION(op, ATNR_CHAOS, IVAL);
^protect_drain{S}    SET_PROTECTION(op, ATNR_DRAIN, IVAL);
^protect_slow{S}     SET_PROTECTION(op, ATNR_SLOW, IVAL);
^protect_confusion{S} SET_PROTECTION(op, ATNR_CONFUSION, IVAL);

^protect_internal{S} SET_PROTECTION(op, ATNR_INTERNAL, IVAL);

    /* The following protections are deprecated, and are here only
     * for backwards compatibility.
     * TODO remove these at some point. */
^protect_body{S}     SET_PROTECTION(op, ATNR_BLIND, IVAL);
^protect_psionic{S}  SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_corruption{S} SET_PROTECTION(op, ATNR_CONFUSION, IVAL);
^protect_spiritual{S} SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_death{S}    SET_PROTECTION(op, ATNR_DRAIN, IVAL);

^movement_type{S}    op->move_type = IVAL;
^attack_move_type{S} op->attack_move_type = IVAL;

^move_state{S}       op->move_status = IVAL;
^confused{S}         CHANGE_FLAG(op, FLAG_CONFUSED, IVAL);
^stealth{S}          CHANGE_FLAG(op, FLAG_STEALTH, IVAL);
^connected{S}        connection_object_add(op, op->map, IVAL);
^cursed{S}           CHANGE_FLAG(op, FLAG_CURSED, IVAL);
^damned{S}           CHANGE_FLAG(op, FLAG_DAMNED, IVAL);
^is_buildable{S}     CHANGE_FLAG(op, FLAG_IS_BUILDABLE, IVAL);
^no_pvp{S}           CHANGE_FLAG(op, FLAG_NO_PVP, IVAL);
^known_magical{S}    {/* DEPRECATED */}
^known_cursed{S}     {/* DEPRECATED */}
^attacktype{S}       {/* DEPRECATED */}
^can_use_skill{S}    {/* DEPRECATED */}
^been_applied{S}     CHANGE_FLAG(op, FLAG_BEEN_APPLIED, IVAL);
^title{S}            {
    const char *y = yval();

    if (*y == '\0') {
        LOG(ERROR, "Title without value.");
    } else {
        FREE_AND_COPY_HASH(op->title, y);

        if (op->title == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->title);
        }
    }
}
^outdoor{S}          CHANGE_FLAG(op, FLAG_OUTDOOR, IVAL);
^unique{S}           CHANGE_FLAG(op, FLAG_UNIQUE, IVAL);
^inv_locked{S}       CHANGE_FLAG(op, FLAG_INV_LOCKED, IVAL);
^is_wooded{S}        {/* DEPRECATED */}
^is_hilly{S}         {/* DEPRECATED */}
^has_ready_skill{S}  {/* DEPRECATED */}
^has_ready_weapon{S} CHANGE_FLAG(op, FLAG_READY_WEAPON, IVAL);
^no_skill_ident{S}   CHANGE_FLAG(op, FLAG_NO_SKILL_IDENT, IVAL);
^glow_radius{S}      op->glow_radius = IVAL;
^is_blind{S}         CHANGE_FLAG(op, FLAG_BLIND, IVAL);
^can_see_in_dark{S}  CHANGE_FLAG(op, FLAG_SEE_IN_DARK, IVAL);
^is_cauldron{S}      CHANGE_FLAG(op, FLAG_IS_CAULDRON, IVAL);
^randomitems{S}      op->randomitems = find_treasurelist(yval());
^is_dust{S}          CHANGE_FLAG(op, FLAG_DUST, IVAL);
^no_steal{S}         {/* DEPRECATED */}
^one_hit{S}          CHANGE_FLAG(op, FLAG_ONE_HIT, IVAL);
^is_vul_elemental{S} {/* DEPRECATED */}
^is_proof_elemental{S} {/* DEPRECATED */}
^is_vul_magic{S}     {/* DEPRECATED */}
^is_proof_magic{S}   {/* DEPRECATED */}
^is_vul_physical{S}  {/* DEPRECATED */}
^is_proof_physical{S} {/* DEPRECATED */}
^is_vul_sphere{S}    {/* DEPRECATED */}
^is_proof_sphere{S}  {/* DEPRECATED */}
^is_indestructible{S} CHANGE_FLAG(op, FLAG_INDESTRUCTIBLE, IVAL);
^soulbound{S}        CHANGE_FLAG(op, FLAG_SOULBOUND, IVAL);

    /* Ignore editor_folder values. */
^editor_folder{S}    {}
^sub_type{S}         op->sub_type = IVAL;
^terrain_flag{S}     op->terrain_flag = IVAL;
^terrain_type{S}     op->terrain_type = IVAL;
^item_quality{S}     op->item_quality = IVAL;
^item_condition{S}   op->item_condition = IVAL;
^item_race{S}        op->item_race = IVAL;
^item_skill{S}       op->item_skill = IVAL;
^item_level{S}       op->item_level = IVAL;
^item_level_art{S}   {
    /* Artifact list token - Never use in real arches or maps. */
    int ival_tmp = IVAL;

    /* When we have an artifact which has a minimum use level of 10
     * but we give it a mithril armour of default use level 50,
     * we will create artifact mithril armour usable for level 10!
     * This code prevents such things from happening. */
    if (ival_tmp <= 0) {
        op->item_level = -ival_tmp;
    } else if (ival_tmp > op->item_level) {
        op->item_level = ival_tmp;
    }
}
^material_real{S}    {
    op->material_real = IVAL;

    if (op->item_quality == 0) {
        op->item_quality = material_real[op->material_real].quality;
        op->item_condition = op->item_quality;
    }
}
^mpart_id{S}         op->quick_pos |= IVAL << 4;
^mpart_nr{S}         op->quick_pos |= IVAL;
^weapon_speed{S}     {
    op->weapon_speed = FVAL;
    op->weapon_speed_left = 0.0;
}
^item_power{S}       op->item_power = IVAL;
^match{S}            {
    sound_ambient_match_parse(op, yval());
}

<*>(^{WS})|{NL}      {}
#.*{NL}              {}

<<EOF>>              {
    /* If we got an error, return the error. Otherwise, return that we got
     * EOF. */
    if (lex_error != 0) {
        return lex_error;
    }
    else {
        return LL_EOF;
    }
}
.*                   add_key_value(op);
%%

#pragma GCC diagnostic pop

/**
 * Used to report an error when parsing object data.
 * @param s The error to report.
 * @return Always returns -1. */
int yyerror(char *s)
{
    LOG(BUG, "%s: %s", s, yytext);
    return -1;
}

/**
 * Returns the next token for lex.
 *
 * Our save file syntax is very simple, so we can use a very simple
 * processing mechanism here instead using something like bison.
 *
 * This skips over the space and returns the value, or "" if no value is
 * found.
 */
static const char *
yval (void)
{
    static const char *em = "";
    char *cp, *end;
    size_t len = yyleng;

    /* First skip over start of line, like animation or name */
    for (cp = yytext; *cp != ' '; cp++, len--) {
        if (*cp == '\0') {
            return em;
        }
    }

    /* Skip over whitespace */
    for (; *cp == ' '; cp++, len--) {
        if (*cp == '\0') {
            return em;
        }
    }

    /* Get last character before null and strip
     * off trailing whitespace. */
    for (end = cp + len - 1; *end == ' ' || *end == 0x0A || *end == 0x0D;
            end--) {
        if (end == cp) {
            return em;
        }

        *end = '\0';
    }

    return cp;
}

/**
 * Frees all memory allocated by the object loader.
 */
void free_object_loader(void)
{
#ifndef WIN32
    yylex_destroy();
#endif
}

/* Buffer functions - needed to make load_object() recursive save. */
void delete_loader_buffer(void *buffer)
{
    if (buffer) {
        yy_delete_buffer(buffer);
    }
    else {
        yy_delete_buffer(YY_CURRENT_BUFFER);
    }

    cur_buffer = NULL;
}

void *create_loader_buffer(void *fp)
{
    cur_buffer = yy_create_buffer(fp, YY_BUF_SIZE);
    yy_switch_to_buffer(cur_buffer);

    return cur_buffer;
}

/**
 * Loads an object from the given file-pointer.
 *
 * Variables will be read, parsed and patched into the object until the
 * string "end" is reached, or the end of the file.
 * @param fp File pointer from which to read.
 * @param op Where to read the data.
 * @param bufstate Used to determine various file attributes:
 * - LO_REPEAT (0): We are reading from the same buffer as the last call.
 * - LO_LINEMODE (1): File that is being read from is multi purpose (ie,
 *   other functions will also be reading from this (treasures file,
 *   artifacts.)
 * - LO_NEWFILE (2): Disabled.
 * - LO_NOREAD (3): Disabled.
 * - LO_MEMORYMODE (4): Read from a memory buffer instead of a file.
 */
int load_object(void *fp, object *op, void *mybuffer, int bufstate,
        int map_flags)
{
    int retval = 0;
    char inbuf[HUGE_BUF];
    object *items[MAXDEPTH];
    int depth = 0;

    items[0] = op;
    art_amask = NULL;

    if (bufstate == LO_REPEAT) {
        /* Be sure we work on the right buffer */
        if (cur_buffer != mybuffer) {
            cur_buffer = mybuffer;
            yy_switch_to_buffer(mybuffer);
        }

        retval = lex_load(&depth, items, MAXDEPTH, map_flags, 0);
    } else if (bufstate == LO_MEMORYMODE) {
        char *strptr = fp;
        YY_BUFFER_STATE yybufstate;
        size_t lcount = 0;

        for ( ; ; ) {
            strptr += lcount;
            lcount = strlen(strptr) + 1;
            yybufstate = yy_scan_string(strptr);
            retval = lex_load(&depth, items, MAXDEPTH, map_flags, 0);
            yy_delete_buffer(yybufstate);

            if (retval == LL_NORMAL) {
                break;
            }
        }

        /* Be sure we work on the right buffer */
        if (cur_buffer != NULL) {
            yy_switch_to_buffer(cur_buffer);
        }
    } else {
        while (fgets(VS(inbuf), fp)) {
            YY_BUFFER_STATE yybufstate = yy_scan_string(inbuf);
            retval = lex_load(&depth, items, MAXDEPTH, map_flags, 1);
            yy_delete_buffer(yybufstate);

            if (retval == LL_NORMAL) {
                /* Be sure we work on the right buffer */
                if (cur_buffer != NULL) {
                    yy_switch_to_buffer(cur_buffer);
                }

                if (depth == 0) {
                    return retval;
                } else {
                    depth--;
                }
            }
        }

        LOG(DEBUG, "Got EOF while scanning strings (%d)", retval);

        /* Be sure we work on the right buffer */
        if (cur_buffer != NULL) {
            yy_switch_to_buffer(cur_buffer);
        }

        return LL_EOF;
    }

    /* OK, now we have our old speed values and our new ones. */
    if (!(map_flags & MAP_STYLE)) {
        if (op->speed < 0.0 && DBL_EQUAL(op->speed_left,
                op->arch->clone.speed_left)) {
            op->speed_left = op->speed_left + rndm(0, 90) / 100.0f;
        }

        if (art_amask != NULL) {
            artifact_change_object(art_amask, op);
        }

        update_ob_speed(op);

        if (object_initializers[op->type]) {
            object_initializers[op->type](op);
        }
    }

    return retval;
}

/**
 * This takes a buffer, scans it for variables, and sets those variables
 * as appropriate in op.
 *
 * This function appears to be used only in @ref c_wiz.c to mutate
 * values.
 * @param op Object to alter.
 * @param buf Modifications to apply. */
int set_variable(object *op, const char *buf)
{
    YY_BUFFER_STATE yybufstate, yycurbuf = YY_CURRENT_BUFFER;
    int retval, depth;
    object *items[MAXDEPTH];

    yy_push_state(INITIAL);
    yybufstate = yy_scan_string(buf);

    items[0] = op;
    depth = 0;
    retval = lex_load(&depth, items, MAXDEPTH, 0, 0);

    if (yycurbuf != NULL) {
        yy_switch_to_buffer(yycurbuf);
    }

    yy_delete_buffer(yybufstate);
    yy_pop_state();

    return retval;
}

/**
 * Generic value saver.
 */
#define SAVE_VALUE(_sb, _name, _value, _fmt) \
    do { \
        stringbuffer_append_printf((_sb), "%s " _fmt "\n", (_name), (_value)); \
    } while (0)
/**
 * Save a string to the specified StringBuffer instance.
 */
#define SAVE_STRING(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%s")
/**
 * Save a double to the specified StringBuffer instance.
 */
#define SAVE_DOUBLE(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%f")
/**
 * Save an int to the specified StringBuffer instance.
 */
#define SAVE_INT(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%d")
/**
 * Save an unsigned int to the specified StringBuffer instance.
 */
#define SAVE_UINT(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%u")
/**
 * Save a 64-bit int to the specified StringBuffer instance.
 */
#define SAVE_INT64(_sb, _name, _value) \
    SAVE_VALUE(_sb, _name, _value, "%" PRId64)
/**
 * Save an unsigned 64-bit int to the specified StringBuffer instance.
 */
#define SAVE_UINT64(_sb, _name, _value) \
    SAVE_VALUE(_sb, _name, _value, "%" PRIu64)

/**
 * Get difference between two objects, and save it in StringBuffer.
 *
 * This function is typically used to dump objects (op2 = empty object),
 * or to save objects (op2 is the objects original archetype).
 * @param sb String buffer to modify.
 * @param op What object the different values will be taken from.
 * @param op2 Object's original archetype. */
void get_ob_diff(StringBuffer *sb, object *op, object *op2)
{
    key_value *my_field, *arch_field;
    int tmp;

    /* This saves the key/value lists. We do it first so that any
     * keys that match field names will be overwritten by the loader. */
    for (my_field = op->key_values; my_field != NULL;
            my_field = my_field->next) {
        /* Find the field in the opposing member. */
        arch_field = object_get_key_link(op2, my_field->key);

        /* If there's no partnering field, or it's got a different value,
         * save our field. */
        if (arch_field == NULL || my_field->value != arch_field->value) {
            stringbuffer_append_string(sb, my_field->key);
            stringbuffer_append_string(sb, " ");

            if (my_field->value != NULL) {
                stringbuffer_append_string(sb, my_field->value);
            }

            stringbuffer_append_string(sb, "\n");
        }
    }

    if (op->name && op->name != op2->name) {
        SAVE_STRING(sb, "name", op->name);
    }

    if (op->custom_name && op->custom_name != op2->custom_name) {
        SAVE_STRING(sb, "custom_name", op->custom_name);
    }

    if (op->glow && op->glow != op2->glow) {
        SAVE_STRING(sb, "glow", op->glow);
    }

    if (op->title && op->title != op2->title) {
        SAVE_STRING(sb, "title", op->title);
    }

    if (op->race && op->race != op2->race) {
        SAVE_STRING(sb, "race", op->race);
    }

    if (op->slaying && op->slaying != op2->slaying) {
        SAVE_STRING(sb, "slaying", op->slaying);
    }

    if (op->msg && op->msg != op2->msg) {
        stringbuffer_append_string(sb, "msg\n");
        stringbuffer_append_string(sb, op->msg);
        stringbuffer_append_string(sb, "\nendmsg\n");
    }

    if (op->artifact && op->artifact != op2->artifact) {
        SAVE_STRING(sb, "artifact", op->artifact);
    }

    if (op->other_arch != op2->other_arch) {
        if (op->other_arch != NULL && op->other_arch->name != NULL) {
            SAVE_STRING(sb, "other_arch", op->other_arch->name);
        }
    }

    if (op->face != op2->face) {
        SAVE_STRING(sb, "face", op->face->name);
    }

    if (op->inv_face != op2->inv_face) {
        SAVE_STRING(sb, "inv_face", op->inv_face->name);
    }

    if (op->animation_id != op2->animation_id) {
        if (op->animation_id != 0) {
            SAVE_STRING(sb, "animation", animations[GET_ANIM_ID(op)].name);
        } else {
            stringbuffer_append_string(sb, "animation NONE\n");
        }
    }

    if (op->inv_animation_id != op2->inv_animation_id) {
        if (op->inv_animation_id != 0) {
            SAVE_STRING(sb, "inv_animation",
                    animations[GET_INV_ANIM_ID(op)].name);
        } else {
            stringbuffer_append_string(sb, "inv_animation NONE\n");
        }
    }

    if (op->anim_speed != op2->anim_speed) {
        SAVE_UINT(sb, "anim_speed", op->anim_speed);
    }

    if (op->stats.wc_range != op2->stats.wc_range) {
        SAVE_UINT(sb, "wc_range", op->stats.wc_range);
    }

    if (op->stats.Str != op2->stats.Str) {
        SAVE_INT(sb, "Str", op->stats.Str);
    }

    if (op->stats.Dex != op2->stats.Dex) {
        SAVE_INT(sb, "Dex", op->stats.Dex);
    }

    if (op->stats.Con != op2->stats.Con) {
        SAVE_INT(sb, "Con", op->stats.Con);
    }

    if (op->stats.Wis != op2->stats.Wis) {
        SAVE_INT(sb, "Wis", op->stats.Wis);
    }

    if (op->stats.Pow != op2->stats.Pow) {
        SAVE_INT(sb, "Pow", op->stats.Pow);
    }

    if (op->stats.Cha != op2->stats.Cha) {
        SAVE_INT(sb, "Cha", op->stats.Cha);
    }

    if (op->stats.Int != op2->stats.Int) {
        SAVE_INT(sb, "Int", op->stats.Int);
    }

    if (op->stats.hp != op2->stats.hp) {
        SAVE_INT(sb, "hp", op->stats.hp);
    }

    if (op->stats.maxhp != op2->stats.maxhp) {
        SAVE_INT(sb, "maxhp", op->stats.maxhp);
    }

    if (op->stats.sp != op2->stats.sp) {
        SAVE_INT(sb, "sp", op->stats.sp);
    }

    if (op->stats.maxsp != op2->stats.maxsp) {
        SAVE_INT(sb, "maxsp", op->stats.maxsp);
    }

    if (op->stats.exp != op2->stats.exp) {
        SAVE_INT64(sb, "exp", op->stats.exp);
    }

    if (op->stats.food != op2->stats.food) {
        SAVE_INT(sb, "food", op->stats.food);
    }

    if (op->stats.dam != op2->stats.dam) {
        SAVE_INT(sb, "dam", op->stats.dam);
    }

    if (op->stats.wc != op2->stats.wc) {
        SAVE_INT(sb, "wc", op->stats.wc);
    }

    if (op->stats.ac != op2->stats.ac) {
        SAVE_INT(sb, "ac", op->stats.ac);
    }

    if (op->x != op2->x) {
        SAVE_INT(sb, "x", op->x);
    }

    if (op->y != op2->y) {
        SAVE_INT(sb, "y", op->y);
    }

    if (op->z != op2->z) {
        SAVE_INT(sb, "z", op->z);
    }

    if (op->zoom_x != op2->zoom_x) {
        SAVE_INT(sb, "zoom_x", op->zoom_x);
    }

    if (op->zoom_y != op2->zoom_y) {
        SAVE_INT(sb, "zoom_y", op->zoom_y);
    }

    if (op->align != op2->align) {
        SAVE_INT(sb, "align", op->align);
    }

    if (op->alpha != op2->alpha) {
        SAVE_UINT(sb, "alpha", op->alpha);
    }

    if (op->glow_speed != op2->glow_speed) {
        SAVE_UINT(sb, "glow_speed", op->glow_speed);
    }

    if (op->rotate != op2->rotate) {
        SAVE_INT(sb, "rotate", op->rotate);
    }

    if (!DBL_EQUAL(op->speed, op2->speed)) {
        SAVE_DOUBLE(sb, "speed", op->speed);
    }

    if (!DBL_EQUAL(op->speed_left, op2->speed_left)) {
        SAVE_DOUBLE(sb, "speed_left", op->speed_left);
    }

    if (op->material_real != op2->material_real) {
        SAVE_INT(sb, "material_real", op->material_real);
    }

    if (op->sub_type != op2->sub_type) {
        SAVE_UINT(sb, "sub_type", op->sub_type);
    }

    if (op->terrain_flag != op2->terrain_flag) {
        SAVE_UINT(sb, "terrain_flag", op->terrain_flag);
    }

    if (op->terrain_type != op2->terrain_type) {
        SAVE_UINT(sb, "terrain_type", op->terrain_type);
    }

    if (op->item_quality != op2->item_quality) {
        SAVE_UINT(sb, "item_quality", op->item_quality);
    }

    if (op->item_condition != op2->item_condition) {
        SAVE_UINT(sb, "item_condition", op->item_condition);
    }

    if (op->item_race != op2->item_race) {
        SAVE_UINT(sb, "item_race", op->item_race);
    }

    if (op->item_skill != op2->item_skill) {
        SAVE_UINT(sb, "item_skill", op->item_skill);
    }

    if (op->item_level != op2->item_level) {
        SAVE_UINT(sb, "item_level", op->item_level);
    }

    if (!DBL_EQUAL(op->weapon_speed, op2->weapon_speed)) {
        SAVE_DOUBLE(sb, "weapon_speed", op->weapon_speed);
    }

    if (op->enemy_count != op2->enemy_count) {
        SAVE_UINT(sb, "object_int1", op->enemy_count);
    }

    if (op->attacked_by_count != op2->attacked_by_count) {
        SAVE_UINT(sb, "object_int2", op->attacked_by_count);
    }

    if (op->ownercount != op2->ownercount) {
        SAVE_UINT(sb, "object_int3", op->ownercount);
    }

    if (op->move_status != op2->move_status) {
        SAVE_INT(sb, "move_state", op->move_status);
    }

    if (op->move_type != op2->move_type) {
        SAVE_UINT(sb, "movement_type", op->move_type);
    }

    if (op->attack_move_type != op2->attack_move_type) {
        SAVE_UINT(sb, "attack_move_type", op->attack_move_type);
    }

    if (op->nrof != op2->nrof) {
        SAVE_UINT(sb, "nrof", op->nrof);
    }

    if (op->level != op2->level) {
        SAVE_INT(sb, "level", op->level);
    }

    if (op->direction != op2->direction) {
        SAVE_INT(sb, "direction", op->direction);
    }

    if (op->type != op2->type) {
        SAVE_UINT(sb, "type", op->type);
    }

    /* attack_save[] holds the attack form also for attack_xx */
    for (tmp = 0; tmp < NROFATTACKS; tmp++) {
        if (op->attack[tmp] != op2->attack[tmp]) {
            stringbuffer_append_printf(sb, "attack_%s %u\n", attack_save[tmp],
                    op->attack[tmp]);
        }

        if (op->protection[tmp] != op2->protection[tmp]) {
            stringbuffer_append_printf(sb, "protect_%s %d\n", attack_save[tmp],
                    op->protection[tmp]);
        }
    }

    if (op->layer != op2->layer) {
        SAVE_UINT(sb, "layer", op->layer);
    }

    if (op->sub_layer != op2->sub_layer) {
        SAVE_UINT(sb, "sub_layer", op->sub_layer);
    }

    if (op->path_attuned != op2->path_attuned) {
        SAVE_UINT(sb, "path_attuned", op->path_attuned);
    }

    if (op->path_repelled != op2->path_repelled) {
        SAVE_UINT(sb, "path_repelled", op->path_repelled);
    }

    if (op->path_denied != op2->path_denied) {
        SAVE_UINT(sb, "path_denied", op->path_denied);
    }

    if (op->material != op2->material) {
        SAVE_UINT(sb, "material", op->material);
    }

    if (op->value != op2->value) {
        SAVE_INT64(sb, "value", op->value);
    }

    if (op->carrying != op2->carrying) {
        SAVE_UINT(sb, "carrying", op->carrying);
    }

    if (op->weight != op2->weight) {
        SAVE_UINT(sb, "weight", op->weight);
    }

    if (op->state != op2->state) {
        SAVE_UINT(sb, "state", op->state);
    }

    if (op->magic != op2->magic) {
        SAVE_INT(sb, "magic", op->magic);
    }

    if (op->last_heal != op2->last_heal) {
        SAVE_INT(sb, "last_heal", op->last_heal);
    }

    if (op->last_sp != op2->last_sp) {
        SAVE_INT(sb, "last_sp", op->last_sp);
    }

    if (op->last_grace != op2->last_grace) {
        SAVE_INT(sb, "last_grace", op->last_grace);
    }

    if (op->last_eat != op2->last_eat) {
        SAVE_INT(sb, "last_eat", op->last_eat);
    }

    if (QUERY_FLAG(op, FLAG_IS_LINKED)) {
        tmp = connection_object_get_value(op);

        if (tmp != 0) {
            SAVE_INT(sb, "connected", tmp);
        }
    }

    if (op->glow_radius != op2->glow_radius) {
        SAVE_INT(sb, "glow_radius", op->glow_radius);
    }

    if (op->randomitems != op2->randomitems) {
        SAVE_STRING(sb, "randomitems",
                op->randomitems != NULL ? op->randomitems->name : "none");
    }

    if (op->run_away != op2->run_away) {
        SAVE_UINT(sb, "run_away", op->run_away);
    }

    if (op->weight_limit != op2->weight_limit) {
        SAVE_UINT(sb, "container", op->weight_limit);
    }

    if (op->behavior != op2->behavior) {
        SAVE_UINT(sb, "behavior", op->behavior);
    }

    if (op->quickslot != op2->quickslot) {
        SAVE_UINT(sb, "quickslot", op->quickslot);
    }

    if (op->item_power != op2->item_power) {
        SAVE_INT(sb, "item_power", op->item_power);
    }

    for (tmp = 0; tmp <= NUM_FLAGS; tmp++) {
        if (object_flag_names[tmp] == NULL) {
            continue;
        }

        uint32_t flag = QUERY_FLAG(op, tmp);
        if (flag != QUERY_FLAG(op2, tmp)) {
            SAVE_STRING(sb, object_flag_names[tmp], flag ? "1" : "0");
        }
    }
}
